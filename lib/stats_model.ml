(* Copy paste from the output files of make stats in /synth_stats_model *)
open Parsetree
open Shared.Ast
open Shared.Util

(* In NLP, probabilities get too small to work with floats directly and the probabilites round off to 0. Work in log(prob) instead. *)

(* Actually, we end up not getting close to 64bit float roundoff, so we could discard this. *)

type lprob = float
let lprob p = log p
let lprob_1 = lprob 1.0
let prob_of_lprob = exp
let mult_lprobs x y = x +. y
let div_lprobs x y = x -. y
let add_lprobs x y =
  if x = neg_infinity then y
  else if y -. x > 500. then y (* Avoid overflow in exp below *)
  else
    x +. log1p(exp(y -. x)) (* === x +. log (1. +. exp(y -. x)) *)

type counts =
  { local_ident_count    : int
  ; external_ident_count : int
  ; tup2_count           : int
  ; tup3_count           : int
  ; tup4_count           : int
  ; tup5_count           : int
  ; const_str_count      : int
  ; const_int_count      : int
  ; const_char_count     : int
  ; const_float_count    : int
  ; let_count            : int
  ; fun_count            : int
  ; app_count            : int
  ; match_count          : int
  ; ite_count            : int
  ; stdlib_ctor_count    : int
  ; nonstdlib_ctor_count : int
  ; record_count         : int
  ; field_count          : int
  }

let counts =
  { local_ident_count    = 79553
  ; external_ident_count = 29224
  ; tup2_count           = 5009
  ; tup3_count           = 1100
  ; tup4_count           = 131
  ; tup5_count           = 67
  ; const_str_count      = 6268
  ; const_int_count      = 7267
  ; const_char_count     = 308
  ; const_float_count    = 60
  ; let_count            = 7553
  ; fun_count            = 21093
  ; app_count            = 41968
  ; match_count          = 3939
  ; ite_count            = 2779
  ; stdlib_ctor_count    = 9293
  ; nonstdlib_ctor_count = 7784 (* include polymorphic variants *)
  ; record_count         = 1262
  ; field_count          = 5403
  }

let lprob_by_counts count total_count = lprob (float_of_int count /. float_of_int total_count)

let ident_count = counts.local_ident_count + counts.external_ident_count
let const_count = counts.const_str_count + counts.const_int_count + counts.const_char_count + counts.const_float_count
let ctor_count  = counts.stdlib_ctor_count + counts.nonstdlib_ctor_count

(* We e-guess 5 term shapes and refine 2 *)
let term_shape_count =
  ident_count +
  const_count +
  counts.app_count +
  counts.ite_count +
  ctor_count +
  counts.match_count +
  counts.fun_count

let ctor_lprob  = lprob_by_counts ctor_count         term_shape_count
let const_lprob = lprob_by_counts const_count        term_shape_count
let app_lprob   = lprob_by_counts counts.app_count   term_shape_count
let ite_lprob   = lprob_by_counts counts.ite_count   term_shape_count
let ident_lprob = lprob_by_counts ident_count        term_shape_count

let match_lprob = lprob_by_counts counts.match_count term_shape_count
let fun_lprob   = lprob_by_counts counts.fun_count   term_shape_count


(* Given we are going to gen a ctor... *)
let stdlib_ctor_lprob    = lprob_by_counts counts.stdlib_ctor_count    ctor_count
let nonstdlib_ctor_lprob = lprob_by_counts counts.nonstdlib_ctor_count ctor_count

(* Given we are going to gen a const... *)
let const_str_lprob   = lprob_by_counts counts.const_str_count   const_count
let const_int_lprob   = lprob_by_counts counts.const_int_count   const_count
let const_char_lprob  = lprob_by_counts counts.const_char_count  const_count
let const_float_lprob = lprob_by_counts counts.const_float_count const_count


let is_channel typ =
  match (Type.regular typ).Types.desc with
  | Types.Tconstr (Path.Pdot (_, "in_channel",  _), [], _) -> true
  | Types.Tconstr (Path.Pdot (_, "out_channel", _), [], _) -> true
  | _ -> false

(* Estimate which functions are imperative. *)
let is_imperative typ =
  let arg_ts, ret_t = Type.args_and_ret typ in
  let flat          = arg_ts @ [ret_t] in
  Type.is_unit_type ret_t ||
  (Type.is_unit_type (List.hd flat) && List.length flat = 2) ||
  List.exists is_channel flat ||
  (typ |> Type.flatten |> List.exists Type.is_ref_type) || (* no refs *)
  (* If output is a type var, make sure one of the inputs is the same *)
  match (Type.regular ret_t).desc with
  | Types.Tvar (Some name) ->
    not (arg_ts |>@@ Type.flatten |> List.exists (Type.tvar_name %> (=) (Some name)))
  | _ -> false


let unimplemented_prim_names = SSet.of_list ["**"; "abs_float"; "acos"; "asin"; "atan"; "atan2"; "ceil"; "copysign"; "cos"; "cosh"; "exp"; "expm1"; "floor"; "hypot"; "ldexp"; "mod_float"; "sin"; "sinh"; "~-."; "sqrt"; "log"; "log10"; "log1p"; "tan"; "tanh"; "frexp"; "classify_float"; "modf"]
let never_synths_right_names = SSet.of_list ["compare"]
(* let comparators              = [">=", "="] *)
let dont_bother_names        = SSet.of_list ["__POS__"; "__POS_OF__"; "__MODULE__"; "__LOC__"; "__LOC_OF__"; "__LINE__"; "__LINE_OF__"; "__FILE__"; "??"; "~+"; ">"; ">="; "@@"; "|>"] (* Don't bother with > and >= because will already guess < and <= *)

let names_to_skip            = SSet.union_all [unimplemented_prim_names; dont_bother_names; never_synths_right_names]



let pervasives_ctors : (Longident.t * Types.constructor_description * lprob) list =
  let ctor_descs = Env.fold_constructors List.cons None(* not looking in a nested module *) Typing.initial_env [] in
  begin fun lid_and_counts ->
    lid_and_counts |>@& begin fun (lid_str, count) ->
      match Longident.parse lid_str, List.find_opt (fun { Types.cstr_name; _ } -> cstr_name = lid_str) ctor_descs with
      | (Longident.Lident _) as lid
      , Some ctor_desc ->
        let lprob = lprob_by_counts count counts.stdlib_ctor_count in
        Some (lid, ctor_desc, lprob)
      | _ -> (* Remove qualified names *)
        None
    end
  end @@
  [ ("::", 2272)
  ; ("[]", 1859)
  ; ("()", 1396)
  ; ("false", 1169)
  ; ("true", 758)
  ; ("None", 670)
  ; ("Some", 623)
  ; ("Error", 174)
  ; ("Arg.Unit", 121)
  ; ("Not_found", 97)
  ; ("Arg.String", 43)
  ; ("Ok", 24)
  ; ("Exit", 17)
  ; ("Arg.Set", 13)
  ; ("Failure", 8)
  ; ("Parsing.YYexit", 7)
  ; ("End_of_file", 6)
  ; ("Open_text", 5)
  ; ("Open_binary", 4)
  ; ("Invalid_argument", 4)
  ; ("Arg.Int", 4)
  ; ("Arg.Expand", 4)
  ; ("Arg.Bad", 3)
  ; ("Open_wronly", 2)
  ; ("Open_trunc", 2)
  ; ("Open_rdonly", 2)
  ; ("Open_creat", 2)
  ; ("Undefined_recursive_module", 1)
  ; ("Stream.Error", 1)
  ; ("Arg.Symbol", 1)
  ; ("Arg.Clear", 1)
  ]

let const_strs : (expression * Types.type_expr * lprob) list =
  begin fun str_str_and_counts ->
    str_str_and_counts |>@ begin fun (str_str, count) ->
      ( Exp.from_string str_str
      , Predef.type_string
      , lprob_by_counts count const_count
      )
    end
  end @@
  [ ("\"Set.bal\"", 248)
  ; ("\"Map.bal\"", 224)
  ; ("\"\"", 179)
  ; ("\"@[<1>{@[%a@ @]}@]\"", 45)
  ; ("\".\"", 39)
  ; ("\")\"", 37)
  ; ("\"Map.disjoint_union %a\"", 30)
  ; ("\"Map.disjoint_union %a => %a <> %a\"", 30)
  ; ("\"@ (@[%a@ %a@])\"", 30)
  ; ("\"%a\"", 26)
  ; ("\" (undocumented)\"", 26)
  ; ("\"%s\"", 25)
  ; ("\"@ %a\"", 24)
  ; ("\" \"", 23)
  ; ("\"(\"", 21)
  ; ("\".cmi\"", 17)
  ; ("\"%a \"", 16)
  ; ("\" ( \"", 15)
  ; ("\"-\"", 14)
  ; ("\".cmx\"", 12)
  ; ("\"%d\"", 12)
  ; ("\"or\"", 11)
  ; ("\"_\"", 11)
  ; ("\"\\n\"", 10)
  ; ("\"*\"", 10)
  ; ("\"%a@.\"", 10)
  ; ("\"method\"", 9)
  ; ("\"[]\"", 9)
  ; ("\">\"", 9)
  ; ("\"+\"", 9)
  ; ("\"()\"", 9)
  ; ("\"}\"", 8)
  ; ("\"{\"", 8)
  ; ("\"type\"", 8)
  ; ("\"end\"", 8)
  ; ("\"OCAMLPARAM\"", 8)
  ; ("\"<\"", 8)
  ; ("\"//toplevel//\"", 8)
  ; ("\", \"", 8)
  ; ("\"true\"", 7)
  ; ("\"set\"", 7)
  ; ("\"pattern\"", 7)
  ; ("\"mod\"", 7)
  ; ("\"false\"", 7)
  ; ("\"and\"", 7)
  ; ("\"::\"", 7)
  ; ("\"lsr\"", 6)
  ; ("\"lsl\"", 6)
  ; ("\"int\"", 6)
  ; ("\"class\"", 6)
  ; ("\"asr\"", 6)
  ; ("\"]\"", 6)
  ; ("\"[\"", 6)
  ; ("\"None\"", 6)
  ; ("\"%a.%a\"", 6)
  ; ("\"%S\"", 6)
  ; ("\"xor\"", 5)
  ; ("\"s\"", 5)
  ; ("\"object\"", 5)
  ; ("\"module\"", 5)
  ; ("\"is not compatible with type\"", 5)
  ; ("\"instance variable\"", 5)
  ; ("\"get\"", 5)
  ; ("\"float\"", 5)
  ; ("\"can't Pmod_unpack\"", 5)
  ; ("\"but is expected to have type\"", 5)
  ; ("\"__\"", 5)
  ; ("\"\\\"\"", 5)
  ; ("\"@]\"", 5)
  ; ("\"/\"", 5)
  ; ("\".cmxa\"", 5)
  ; ("\".cmt\"", 5)
  ; ("\"!=\"", 5)
  ; ("\"~\"", 4)
  ; ("\"val\"", 4)
  ; ("\"unboxed\"", 4)
  ; ("\"tag\"", 4)
  ; ("\"nativeint\"", 4)
  ; ("\"mutable\"", 4)
  ; ("\"lxor\"", 4)
  ; ("\"lor\"", 4)
  ; ("\"land\"", 4)
  ; ("\"int64\"", 4)
  ; ("\"int32\"", 4)
  ; ("\"imul\"", 4)
  ; ("\"gcc -shared -flat_namespace -undefined suppress                    -Wl,-no_compact_unwind\"",
  4)
  ; ("\"env\"", 4)
  ; ("\"dividend\"", 4)
  ; ("\"arg\"", 4)
  ; ("\"alloc\"", 4)
  ; ("\"addr\"", 4)
  ; ("\"_startup\"", 4)
  ; ("\"_none_\"", 4)
  ; ("\"\\\\%o\"", 4)
  ; ("\"\\\"%s\\\"\"", 4)
  ; ("\"Primitive \"", 4)
  ; ("\"@ \"", 4)
  ; ("\"?\"", 4)
  ; ("\">=\"", 4)
  ; ("\"==\"", 4)
  ; ("\"=\"", 4)
  ; ("\"<=\"", 4)
  ; ("\":\"", 4)
  ; ("\"-help\"", 4)
  ; ("\"-I\"", 4)
  ; ("\"-.\"", 4)
  ; ("\"+.\"", 4)
  ; ("\"(root-init)\"", 4)
  ; ("\"(heap-init)\"", 4)
  ; ("\"(%a)\"", 4)
  ; ("\"'\"", 4)
  ; ("\"%s\\n\"", 4)
  ; ("\"!\"", 4)
  ; ("\" not found.\"", 4)
  ; ("\" + %i\"", 4)
  ; ("\"  \"", 4)
  ; ("\"||\"", 3)
  ; ("\"|]\"", 3)
  ; ("\"{}<-\"", 3)
  ; ("\"{}\"", 3)
  ; ("\"with\"", 3)
  ; ("\"while\"", 3)
  ; ("\"switcher\"", 3)
  ; ("\"switch\"", 3)
  ; ("\"sub\"", 3)
  ; ("\"struct\"", 3)
  ; ("\"sig\"", 3)
  ; ("\"neg\"", 3)
  ; ("\"msvc\"", 3)
  ; ("\"mov\"", 3)
  ; ("\"module type\"", 3)
  ; ("\"liveness\"", 3)
  ; ("\"let\"", 3)
  ; ("\"inline\"", 3)
  ; ("\"init_class\"", 3)
  ; ("\"include\"", 3)
  ; ("\"if\"", 3)
  ; ("\"g\"", 3)
  ; ("\"fsubrp\"", 3)
  ; ("\"fsubp\"", 3)
  ; ("\"for\"", 3)
  ; ("\"fdivrp\"", 3)
  ; ("\"fdivp\"", 3)
  ; ("\"extension constructor\"", 3)
  ; ("\"exception\"", 3)
  ; ("\"dummy\"", 3)
  ; ("\"dr\"", 3)
  ; ("\"constructor\"", 3)
  ; ("\"clos\"", 3)
  ; ("\"camlstartup\"", 3)
  ; ("\"caml_young_limit\"", 3)
  ; ("\"caml_tuplify\"", 3)
  ; ("\"caml_string_notequal\"", 3)
  ; ("\"caml_string_compare\"", 3)
  ; ("\"caml_startup\"", 3)
  ; ("\"caml_send\"", 3)
  ; ("\"caml_notequal\"", 3)
  ; ("\"caml_ml_array_bound_error\"", 3)
  ; ("\"caml_lessthan\"", 3)
  ; ("\"caml_lessequal\"", 3)
  ; ("\"caml_greaterthan\"", 3)
  ; ("\"caml_greaterequal\"", 3)
  ; ("\"caml_equal\"", 3)
  ; ("\"caml_curry\"", 3)
  ; ("\"caml_ba_set_\"", 3)
  ; ("\"caml_ba_get_\"", 3)
  ; ("\"caml_apply\"", 3)
  ; ("\"call\"", 3)
  ; ("\"bswap\"", 3)
  ; ("\"begin\"", 3)
  ; ("\"add\"", 3)
  ; ("\"a\"", 3)
  ; ("\"`%s\"", 3)
  ; ("\"]\\n\"", 3)
  ; ("\"\\\"%a\\\"\"", 3)
  ; ("\"[|\"", 3)
  ; ("\"[]\\n\"", 3)
  ; ("\"[]<-\"", 3)
  ; ("\"[\\n\"", 3)
  ; ("\"Win32\"", 3)
  ; ("\"Type\"", 3)
  ; ("\"Strongly_connected_components: missing dependency %a\"", 3)
  ; ("\"Strongly_connected_components.check: the graph has external dependencies (%a -> %a)\"",
  3)
  ; ("\"Some\"", 3)
  ; ("\"@[<v>%a%a@]\"", 3)
  ; ("\"<none>\"", 3)
  ; ("\":=\"", 3)
  ; ("\": \"", 3)
  ; ("\".startup\"", 3)
  ; ("\".rdata\"", 3)
  ; ("\"..\"", 3)
  ; ("\"-unsafe-string\"", 3)
  ; ("\"-ppx\"", 3)
  ; ("\"-pp\"", 3)
  ; ("\"-g\"", 3)
  ; ("\"--help\"", 3)
  ; ("\",%s\"", 3)
  ; ("\",\"", 3)
  ; ("\"+%d\"", 3)
  ; ("\"*match*\"", 3)
  ; ("\"()<-\"", 3)
  ; ("\"'%s\"", 3)
  ; ("\"&&\"", 3)
  ; ("\"%s%s\"", 3)
  ; ("\"%s%c\"", 3)
  ; ("\"%a\\n\"", 3)
  ; ("\"%a%s%a\"", 3)
  ; ("\"%X\"", 3)
  ; ("\"%.12g\"", 3)
  ; ("\"$\"", 3)
  ; ("\"#row\"", 3)
  ; ("\"#\"", 3)
  ; ("\" Print version and exit\"", 3)
  ; ("\"{<\"", 2)
  ; ("\"xorpd\"", 2)
  ; ("\"xchg\"", 2)
  ; ("\"x86_64-apple-darwin19.6.0\"", 2)
  ; ("\"x\"", 2)
  ; ("\"word_size\"", 2)
  ; ("\"when\"", 2)
  ; ("\"virtual\"", 2)
  ; ("\"variant\"", 2)
  ; ("\"value\"", 2)
  ; ("\"untagged\"", 2)
  ; ("\"unsafe_\"", 2)
  ; ("\"unit\"", 2)
  ; ("\"ucomisd\"", 2)
  ; ("\"try\"", 2)
  ; ("\"to\"", 2)
  ; ("\"this type-based \"", 2)
  ; ("\"then\"", 2)
  ; ("\"test\"", 2)
  ; ("\"table\"", 2)
  ; ("\"subsd\"", 2)
  ; ("\"sqrtsd\"", 2)
  ; ("\"specialise\"", 2)
  ; ("\"spacetime_shapes\"", 2)
  ; ("\"size\"", 2)
  ; ("\"shr\"", 2)
  ; ("\"self-\"", 2)
  ; ("\"self\"", 2)
  ; ("\"sar\"", 2)
  ; ("\"sal\"", 2)
  ; ("\"rsi\"", 2)
  ; ("\"ret\"", 2)
  ; ("\"record\"", 2)
  ; ("\"rec\"", 2)
  ; ("\"rdx\"", 2)
  ; ("\"rdi\"", 2)
  ; ("\"rcx\"", 2)
  ; ("\"rbx\"", 2)
  ; ("\"rbp\"", 2)
  ; ("\"rax\"", 2)
  ; ("\"ranlib\"", 2)
  ; ("\"raise_notrace\"", 2)
  ; ("\"raise\"", 2)
  ; ("\"r9\"", 2)
  ; ("\"r8\"", 2)
  ; ("\"r13\"", 2)
  ; ("\"r12\"", 2)
  ; ("\"r11\"", 2)
  ; ("\"r10\"", 2)
  ; ("\"push\"", 2)
  ; ("\"ptr\"", 2)
  ; ("\"private\"", 2)
  ; ("\"pop\"", 2)
  ; ("\"parsing\"", 2)
  ; ("\"parser\"", 2)
  ; ("\"p\"", 2)
  ; ("\"open\"", 2)
  ; ("\"opaque\"", 2)
  ; ("\"of\"", 2)
  ; ("\"ocaml.unboxed\"", 2)
  ; ("\"obj_init\"", 2)
  ; ("\"nop\"", 2)
  ; ("\"nonrec\"", 2)
  ; ("\"nonrec flag\"", 2)
  ; ("\"non-integer parameter for \\\"%s\\\"\"", 2)
  ; ("\"noalloc\"", 2)
  ; ("\"no\"", 2)
  ; ("\"new_variable\"", 2)
  ; ("\"new\"", 2)
  ; ("\"neg_infinity\"", 2)
  ; ("\"nan\"", 2)
  ; ("\"mutating field %s\"", 2)
  ; ("\"mulsd\"", 2)
  ; ("\"movss\"", 2)
  ; ("\"movsd\"", 2)
  ; ("\"movlpd\"", 2)
  ; ("\"movapd\"", 2)
  ; ("\"movabsq\"", 2)
  ; ("\"mod_unsafe\"", 2)
  ; ("\"match\"", 2)
  ; ("\"lzarg\"", 2)
  ; ("\"leave\"", 2)
  ; ("\"lea\"", 2)
  ; ("\"lazy\"", 2)
  ; ("\"label\"", 2)
  ; ("\"l\"", 2)
  ; ("\"jmp\"", 2)
  ; ("\"j\"", 2)
  ; ("\"its constructor has more than one argument\"", 2)
  ; ("\"it is mutable\"", 2)
  ; ("\"int_size\"", 2)
  ; ("\"initializer\"", 2)
  ; ("\"inherit\"", 2)
  ; ("\"infinity\"", 2)
  ; ("\"inc\"", 2)
  ; ("\"in\"", 2)
  ; ("\"immutable\"", 2)
  ; ("\"imm\"", 2)
  ; ("\"idiv\"", 2)
  ; ("\"identifier\"", 2)
  ; ("\"gcc -O2 -fno-strict-aliasing -fwrapv -Wall -Werror -D_FILE_OFFSET_BITS=64 -D_REENTRANT -DCAML_NAME_SPACE   -Wl,-no_compact_unwind\"",
  2)
  ; ("\"gc_roots\"", 2)
  ; ("\"fyl2x\"", 2)
  ; ("\"fxch\"", 2)
  ; ("\"functor\"", 2)
  ; ("\"function\"", 2)
  ; ("\"fun\"", 2)
  ; ("\"fsubr\"", 2)
  ; ("\"fsub\"", 2)
  ; ("\"fsqrt\"", 2)
  ; ("\"fsin\"", 2)
  ; ("\"frametable\"", 2)
  ; ("\"fptan\"", 2)
  ; ("\"fpatan\"", 2)
  ; ("\"fnstsw\"", 2)
  ; ("\"fnstcw\"", 2)
  ; ("\"fmulp\"", 2)
  ; ("\"fmul\"", 2)
  ; ("\"float64\"", 2)
  ; ("\"float32\"", 2)
  ; ("\"fldz\"", 2)
  ; ("\"fldln2\"", 2)
  ; ("\"fldlg2\"", 2)
  ; ("\"fldcw\"", 2)
  ; ("\"fld1\"", 2)
  ; ("\"flambda\"", 2)
  ; ("\"fistp\"", 2)
  ; ("\"fild\"", 2)
  ; ("\"field\"", 2)
  ; ("\"fdivr\"", 2)
  ; ("\"fdiv\"", 2)
  ; ("\"fcos\"", 2)
  ; ("\"fcompp\"", 2)
  ; ("\"fcomp\"", 2)
  ; ("\"fchs\"", 2)
  ; ("\"faddp\"", 2)
  ; ("\"fadd\"", 2)
  ; ("\"fabs\"", 2)
  ; ("\"external\"", 2)
  ; ("\"exn\"", 2)
  ; ("\"envs\"", 2)
  ; ("\"env_init\"", 2)
  ; ("\"entry\"", 2)
  ; ("\"else\"", 2)
  ; ("\"dumb\"", 2)
  ; ("\"downto\"", 2)
  ; ("\"done\"", 2)
  ; ("\"do\"", 2)
  ; ("\"divsd\"", 2)
  ; ("\"divisor\"", 2)
  ; ("\"definition\"", 2)
  ; ("\"dec\"", 2)
  ; ("\"data_end\"", 2)
  ; ("\"data_begin\"", 2)
  ; ("\"cvttsd2si\"", 2)
  ; ("\"cvtss2sd\"", 2)
  ; ("\"cvtsi2sd\"", 2)
  ; ("\"cvtsd2ss\"", 2)
  ; ("\"cvtsd2si\"", 2)
  ; ("\"create_object_opt\"", 2)
  ; ("\"constructor \"", 2)
  ; ("\"constraint\"", 2)
  ; ("\"comisd\"", 2)
  ; ("\"code_end\"", 2)
  ; ("\"code_begin\"", 2)
  ; ("\"cmp\"", 2)
  ; ("\"cmov\"", 2)
  ; ("\"class type\"", 2)
  ; ("\"case\"", 2)
  ; ("\"camlppx\"", 2)
  ; ("\"caml_young_ptr\"", 2)
  ; ("\"caml_string_lessthan\"", 2)
  ; ("\"caml_string_lessequal\"", 2)
  ; ("\"caml_string_greaterthan\"", 2)
  ; ("\"caml_string_greaterequal\"", 2)
  ; ("\"caml_string_get64\"", 2)
  ; ("\"caml_string_equal\"", 2)
  ; ("\"caml_spacetime_shapes\"", 2)
  ; ("\"caml_setup_afl\"", 2)
  ; ("\"caml_restore_raw_backtrace\"", 2)
  ; ("\"caml_raise_exn\"", 2)
  ; ("\"caml_obj_tag\"", 2)
  ; ("\"caml_obj_dup\"", 2)
  ; ("\"caml_negf_mask\"", 2)
  ; ("\"caml_nativeint_compare\"", 2)
  ; ("\"caml_make_vect\"", 2)
  ; ("\"caml_int_compare\"", 2)
  ; ("\"caml_int64_xor\"", 2)
  ; ("\"caml_int64_to_nativeint\"", 2)
  ; ("\"caml_int64_to_int32\"", 2)
  ; ("\"caml_int64_to_int\"", 2)
  ; ("\"caml_int64_sub\"", 2)
  ; ("\"caml_int64_shift_right_unsigned\"", 2)
  ; ("\"caml_int64_shift_right\"", 2)
  ; ("\"caml_int64_shift_left\"", 2)
  ; ("\"caml_int64_or\"", 2)
  ; ("\"caml_int64_of_nativeint\"", 2)
  ; ("\"caml_int64_of_int32\"", 2)
  ; ("\"caml_int64_of_int\"", 2)
  ; ("\"caml_int64_neg\"", 2)
  ; ("\"caml_int64_mul\"", 2)
  ; ("\"caml_int64_mod\"", 2)
  ; ("\"caml_int64_div\"", 2)
  ; ("\"caml_int64_compare\"", 2)
  ; ("\"caml_int64_bswap\"", 2)
  ; ("\"caml_int64_and\"", 2)
  ; ("\"caml_int64_add\"", 2)
  ; ("\"caml_int32_compare\"", 2)
  ; ("\"caml_initialize\"", 2)
  ; ("\"caml_globals_inited\"", 2)
  ; ("\"caml_globals\"", 2)
  ; ("\"caml_get_public_method\"", 2)
  ; ("\"caml_fresh_oo_id\"", 2)
  ; ("\"caml_frametable\"", 2)
  ; ("\"caml_float_compare\"", 2)
  ; ("\"caml_exn_Division_by_zero\"", 2)
  ; ("\"caml_exn_\"", 2)
  ; ("\"caml_compare\"", 2)
  ; ("\"caml_call_gc\"", 2)
  ; ("\"caml_c_call\"", 2)
  ; ("\"caml_bytes_set64\"", 2)
  ; ("\"caml_bytes_notequal\"", 2)
  ; ("\"caml_bytes_lessthan\"", 2)
  ; ("\"caml_bytes_lessequal\"", 2)
  ; ("\"caml_bytes_greaterthan\"", 2)
  ; ("\"caml_bytes_greaterequal\"", 2)
  ; ("\"caml_bytes_get64\"", 2)
  ; ("\"caml_bytes_equal\"", 2)
  ; ("\"caml_bytes_compare\"", 2)
  ; ("\"caml_ba_uint8_set64\"", 2)
  ; ("\"caml_ba_uint8_get64\"", 2)
  ; ("\"caml_allocN\"", 2)
  ; ("\"caml_alloc3\"", 2)
  ; ("\"caml_alloc2\"", 2)
  ; ("\"caml_alloc1\"", 2)
  ; ("\"caml_absf_mask\"", 2)
  ; ("\"caml\"", 2)
  ; ("\"cached\"", 2)
  ; ("\"bad value for %s\"", 2)
  ; ("\"bad input: format type mismatch between %S and %S\"", 2)
  ; ("\"ba\"", 2)
  ; ("\"b\"", 2)
  ; ("\"assert\"", 2)
  ; ("\"as\"", 2)
  ; ("\"andpd\"", 2)
  ; ("\"addsd\"", 2)
  ; ("\"`\"", 2)
  ; ("\"_closure\"", 2)
  ; ("\"__dummy__\"", 2)
  ; ("\"__TEXT\"", 2)
  ; ("\"\\t%s\\t%s\"", 2)
  ; ("\"\\t%s\\t%a, %a\"", 2)
  ; ("\"\\t%s\\t%a\"", 2)
  ; ("\"\\t%s\"", 2)
  ; ("\"\\nThe first one was selected. Please disambiguate if this is wrong.\"",
  2)
  ; ("\"\\n@?\"", 2)
  ; ("\"\\\"%s\\\"\\n\"", 2)
  ; ("\"[P%d]\"", 2)
  ; ("\"[%s]\"", 2)
  ; ("\"Wrong approximation for [Project_closure] when being used as a [constant_defining_value]: %a\"",
  2)
  ; ("\"Virtual\"", 2)
  ; ("\"Up\"", 2)
  ; ("\"Unix\"", 2)
  ; ("\"Undefined_recursive_module\"", 2)
  ; ("\"Uncaught exception: %s\\n\"", 2)
  ; ("\"Unbound module type %a\"", 2)
  ; ("\"Unbound module %a\"", 2)
  ; ("\"Unbound instance variable %s\"", 2)
  ; ("\"Their internal representations differ:@ %s %s %s\"", 2)
  ; ("\"The constructor\"", 2)
  ; ("\"TERM\"", 2)
  ; ("\"Sys_error\"", 2)
  ; ("\"Sys_blocked_io\"", 2)
  ; ("\"Subst.modtype_path\"", 2)
  ; ("\"String.rindex_from_opt / Bytes.rindex_from_opt\"", 2)
  ; ("\"String.rindex_from / Bytes.rindex_from\"", 2)
  ; ("\"String.rcontains_from / Bytes.rcontains_from\"", 2)
  ; ("\"String.index_from_opt / Bytes.index_from_opt\"", 2)
  ; ("\"String.index_from / Bytes.index_from\"", 2)
  ; ("\"String.contains_from / Bytes.contains_from\"", 2)
  ; ("\"String\"", 2)
  ; ("\"Stdlib\"", 2)
  ; ("\"Stack_overflow\"", 2)
  ; ("\"Some\\n\"", 2)
  ; ("\"Share_constants\"", 2)
  ; ("\"Series is closed\"", 2)
  ; ("\"Rec\"", 2)
  ; ("\"Pxorint\"", 2)
  ; ("\"Pxorbint\"", 2)
  ; ("\"Public\"", 2)
  ; ("\"Psubint\"", 2)
  ; ("\"Psubfloat\"", 2)
  ; ("\"Psubbint\"", 2)
  ; ("\"Pstringrefu\"", 2)
  ; ("\"Pstringrefs\"", 2)
  ; ("\"Pstringlength\"", 2)
  ; ("\"Pstring_load_64\"", 2)
  ; ("\"Pstring_load_32\"", 2)
  ; ("\"Pstring_load_16\"", 2)
  ; ("\"Psetglobal\"", 2)
  ; ("\"Psetfloatfield\"", 2)
  ; ("\"Psetfield_computed\"", 2)
  ; ("\"Psetfield\"", 2)
  ; ("\"Psequor\"", 2)
  ; ("\"Psequand\"", 2)
  ; ("\"Private\"", 2)
  ; ("\"Prevapply\"", 2)
  ; ("\"Praise\"", 2)
  ; ("\"Porint\"", 2)
  ; ("\"Porbint\"", 2)
  ; ("\"Popaque\"", 2)
  ; ("\"Poffsetref\"", 2)
  ; ("\"Poffsetint\"", 2)
  ; ("\"Pnot\"", 2)
  ; ("\"Pnegint\"", 2)
  ; ("\"Pnegfloat\"", 2)
  ; ("\"Pnegbint\"", 2)
  ; ("\"Pmulint\"", 2)
  ; ("\"Pmulfloat\"", 2)
  ; ("\"Pmulbint\"", 2)
  ; ("\"Pmodint\"", 2)
  ; ("\"Pmodbint\"", 2)
  ; ("\"Pmakeblock\"", 2)
  ; ("\"Pmakearray\"", 2)
  ; ("\"Plsrint\"", 2)
  ; ("\"Plsrbint\"", 2)
  ; ("\"Plslint\"", 2)
  ; ("\"Plslbint\"", 2)
  ; ("\"Pisout\"", 2)
  ; ("\"Pisint\"", 2)
  ; ("\"Pintoffloat\"", 2)
  ; ("\"Pintofbint\"", 2)
  ; ("\"Pintcomp\"", 2)
  ; ("\"Pint_as_pointer\"", 2)
  ; ("\"Pignore\"", 2)
  ; ("\"Pidentity\"", 2)
  ; ("\"Pgetglobal\"", 2)
  ; ("\"Pfloatofint\"", 2)
  ; ("\"Pfloatfield\"", 2)
  ; ("\"Pfloatcomp\"", 2)
  ; ("\"Pfield_computed\"", 2)
  ; ("\"Pfield\"", 2)
  ; ("\"Pduprecord\"", 2)
  ; ("\"Pduparray\"", 2)
  ; ("\"Pdivint\"", 2)
  ; ("\"Pdivfloat\"", 2)
  ; ("\"Pdivbint\"", 2)
  ; ("\"Pdirapply\"", 2)
  ; ("\"Pcvtbint\"", 2)
  ; ("\"Pctconst\"", 2)
  ; ("\"Pccall\"", 2)
  ; ("\"Pbytessetu\"", 2)
  ; ("\"Pbytessets\"", 2)
  ; ("\"Pbytesrefu\"", 2)
  ; ("\"Pbytesrefs\"", 2)
  ; ("\"Pbyteslength\"", 2)
  ; ("\"Pbytes_to_string\"", 2)
  ; ("\"Pbytes_set_64\"", 2)
  ; ("\"Pbytes_set_32\"", 2)
  ; ("\"Pbytes_set_16\"", 2)
  ; ("\"Pbytes_of_string\"", 2)
  ; ("\"Pbytes_load_64\"", 2)
  ; ("\"Pbytes_load_32\"", 2)
  ; ("\"Pbytes_load_16\"", 2)
  ; ("\"Pbswap16\"", 2)
  ; ("\"Pbintofint\"", 2)
  ; ("\"Pbintcomp\"", 2)
  ; ("\"Pbigstring_set_64\"", 2)
  ; ("\"Pbigstring_set_32\"", 2)
  ; ("\"Pbigstring_set_16\"", 2)
  ; ("\"Pbigstring_load_64\"", 2)
  ; ("\"Pbigstring_load_32\"", 2)
  ; ("\"Pbigstring_load_16\"", 2)
  ; ("\"Pbigarrayset\"", 2)
  ; ("\"Pbigarrayref\"", 2)
  ; ("\"Pbigarraydim\"", 2)
  ; ("\"Pbbswap\"", 2)
  ; ("\"Pasrint\"", 2)
  ; ("\"Pasrbint\"", 2)
  ; ("\"Parraysetu\"", 2)
  ; ("\"Parraysets\"", 2)
  ; ("\"Parrayrefu\"", 2)
  ; ("\"Parrayrefs\"", 2)
  ; ("\"Parraylength\"", 2)
  ; ("\"Pandint\"", 2)
  ; ("\"Pandbint\"", 2)
  ; ("\"Paddint\"", 2)
  ; ("\"Paddfloat\"", 2)
  ; ("\"Paddbint\"", 2)
  ; ("\"Pabsfloat\"", 2)
  ; ("\"Override\"", 2)
  ; ("\"Out_of_memory\"", 2)
  ; ("\"Optional \\\"%s\\\"\\n\"", 2)
  ; ("\"Open\"", 2)
  ; ("\"Obj.extension_constructor\"", 2)
  ; ("\"OCAML_COLOR\"", 2)
  ; ("\"Not_found\"", 2)
  ; ("\"Nonrec\"", 2)
  ; ("\"None\\n\"", 2)
  ; ("\"Nolabel\\n\"", 2)
  ; ("\"Mutable\"", 2)
  ; ("\"Missing key in argument specification\"", 2)
  ; ("\"Match_failure\"", 2)
  ; ("\"Marshal.from_bytes\"", 2)
  ; ("\"List.nth\"", 2)
  ; ("\"Lift_constants\"", 2)
  ; ("\"Labelled \\\"%s\\\"\\n\"", 2)
  ; ("\"It must be either empty, 'always' or 'never'\"", 2)
  ; ("\"Invalid_argument\"", 2)
  ; ("\"In this definition, a type variable has a variance that\"", 2)
  ; ("\"Immutable\"", 2)
  ; ("\"Ill-formed list of warnings\"", 2)
  ; ("\"Genarray\"", 2)
  ; ("\"Freshening.Project_var.compose: domains of substitutions must be disjoint.  earlier=%a later=%a\"",
  2)
  ; ("\"Fresh\"", 2)
  ; ("\"Fatal error: exception %s\\n\"", 2)
  ; ("\"Failure\"", 2)
  ; ("\"Expected declaration\"", 2)
  ; ("\"End_of_file\"", 2)
  ; ("\"Down\"", 2)
  ; ("\"Division_by_zero\"", 2)
  ; ("\"Digest.from_hex\"", 2)
  ; ("\"Concrete\"", 2)
  ; ("\"Closed\"", 2)
  ; ("\"Change one of them.\"", 2)
  ; ("\"Cannot find file %s\"", 2)
  ; ("\"Bigarray.Array3.of_array: non-cubic data\"", 2)
  ; ("\"Bad definition for float array member %a: %a\"", 2)
  ; ("\"BYTE\"", 2)
  ; ("\"Assert_failure\"", 2)
  ; ("\"Array3\"", 2)
  ; ("\"Array2\"", 2)
  ; ("\"Array1\"", 2)
  ; ("\"Array\"", 2)
  ; ("\"A type parameter occurs several times\"", 2)
  ; ("\"@}\"", 2)
  ; ("\"@progbits\"", 2)
  ; ("\"@[The type of this class,@ %a,@ contains type variables that cannot be generalized@]\"",
  2)
  ; ("\"@[Bad -I option: %s@]@.\"", 2)
  ; ("\"@[<v>\"", 2)
  ; ("\"@[<2>%a@ =@ %a@]\"", 2)
  ; ("\"@[<2>%a:%t@]@.\"", 2)
  ; ("\"@[%s@ %s@]\"", 2)
  ; ("\"@[%s@ %s@ It\"", 2)
  ; ("\"@[%s@ %a@]\"", 2)
  ; ("\"@[%s@ %a@ %s@]\"", 2)
  ; ("\"@?\"", 2)
  ; ("\"@.cmm:@.\"", 2)
  ; ("\"@,endswitch\"", 2)
  ; ("\"@,Self type cannot be unified with a closed object type\"", 2)
  ; ("\"@,@[The type constructor@;<1 2>%a@ would escape its scope@]\"", 2)
  ; ("\"@\"", 2)
  ; ("\"@ %s\"", 2)
  ; ("\">}\"", 2)
  ; ("\"<plugin>  Load dynamic plugin <plugin>\"", 2)
  ; ("\"<module>  Opens the module <module> before typing\"", 2)
  ; ("\"<dir>  Add <dir> to the list of include directories\"", 2)
  ; ("\";\"", 2)
  ; ("\"; \"", 2)
  ; ("\":\\n \"", 2)
  ; ("\"4\"", 2)
  ; ("\"3\"", 2)
  ; ("\"1\"", 2)
  ; ("\"0\"", 2)
  ; ("\"/f\"", 2)
  ; ("\"//\"", 2)
  ; ("\"/%i\"", 2)
  ; ("\".rodata.cst8\"", 2)
  ; ("\".o\"", 2)
  ; ("\".mli\"", 2)
  ; ("\".ml\"", 2)
  ; ("\".cmxs\"", 2)
  ; ("\".cmo\"", 2)
  ; ("\".c\"", 2)
  ; ("\".annot\"", 2)
  ; ("\"./\"", 2)
  ; ("\"../\"", 2)
  ; ("\"-vnum\"", 2)
  ; ("\"-version\"", 2)
  ; ("\"-shared\"", 2)
  ; ("\"-plugin\"", 2)
  ; ("\"-pack\"", 2)
  ; ("\"-open\"", 2)
  ; ("\"-noautolink\"", 2)
  ; ("\"-l\"", 2)
  ; ("\"-intf\"", 2)
  ; ("\"-impl\"", 2)
  ; ("\"-for-pack\"", 2)
  ; ("\"-f\"", 2)
  ; ("\"-depend\"", 2)
  ; ("\"-args0\"", 2)
  ; ("\"-args\"", 2)
  ; ("\"-absname\"", 2)
  ; ("\"-L\"", 2)
  ; ("\"-D_FILE_OFFSET_BITS=64 -D_REENTRANT\"", 2)
  ; ("\"+f\"", 2)
  ; ("\"+=\"", 2)
  ; ("\"*f\"", 2)
  ; ("\"*extension*\"", 2)
  ; ("\"*** %s@.%a@.\"", 2)
  ; ("\")\\n\"", 2)
  ; ("\"(mutable) %a -> %a@ \"", 2)
  ; ("\"(init)\"", 2)
  ; ("\"(assign)\"", 2)
  ; ("\"(Unknown_or_mutable)\"", 2)
  ; ("\"(Program not linked with -g, cannot print stack backtrace)\\n\"", 2)
  ; ("\"(Contents ...)\"", 2)
  ; ("\"((size %d) (contents %a))\"", 2)
  ; ("\"(%s)\"", 2)
  ; ("\"(%a..%a)\"", 2)
  ; ("\"&\"", 2)
  ; ("\"%s_%i\"", 2)
  ; ("\"%s[%d]\"", 2)
  ; ("\"%s[%d,%d+%d]\"", 2)
  ; ("\"%s:\"", 2)
  ; ("\"%s: %s\"", 2)
  ; ("\"%s \"", 2)
  ; ("\"%i\"", 2)
  ; ("\"%f\"", 2)
  ; ("\"%a.(%d)\"", 2)
  ; ("\"%a%s%i\"", 2)
  ; ("\"%a%s\"", 2)
  ; ("\"%a -> %i@ \"", 2)
  ; ("\"%a -> %a@ \"", 2)
  ; ("\"%Ld\"", 2)
  ; ("\"%C\"", 2)
  ; ("\"%\"", 2)
  ; ("\"#modulepat\"", 2)
  ; ("\" | \"", 2)
  ; ("\" is never used to build values.\\n(However, this constructor appears in patterns.)\"",
  2)
  ; ("\" ghost\"", 2)
  ; ("\" disambiguation\"", 2)
  ; ("\" Show absolute filenames in error messages\"", 2)
  ; ("\" Print version number and exit\"", 2)
  ; ("\" Display this list of options\"", 2)
  ; ("\" (%a, @ %a)\"", 2)
  ; ("\" (%a, %a)\"", 2)
  ; ("\" %s\"", 2)
  ]
  (* Eliding strings that occur more rarely (not accounted for in counts...oh well it's stats) *)


let const_strs_3_chars_or_less =
  const_strs
  |> List.filter (fun (str_exp, _, _) -> (Exp.string str_exp |>& String.length ||& max_int) <= 3)

let const_strs_2_chars_or_less =
  const_strs
  |> List.filter (fun (str_exp, _, _) -> (Exp.string str_exp |>& String.length ||& max_int) <= 2)

let const_strs_1_char_or_less =
  const_strs
  |> List.filter (fun (str_exp, _, _) -> (Exp.string str_exp |>& String.length ||& max_int) <= 1)

let const_ints : (expression * Types.type_expr * lprob) list =
  begin fun int_str_and_counts ->
    int_str_and_counts |>@ begin fun (int_str, count) ->
      ( Exp.from_string int_str
      , Predef.type_int
      , lprob_by_counts count const_count
      )
    end
  end @@
  [ ("0", 2685)
  ; ("1", 1896)
  ; ("2", 732)
  ; ("3", 248)
  ; ("4", 195)
  ; ("8", 119)
  ; ("5", 108)
  ; ("(-1)", 82)
  (* ; ("6", 66)
  ; ("16", 63)
  ; ("10", 58)
  ; ("7", 39)
  ; ("100", 39)
  ; ("42", 37)
  ; ("32", 24)
  ; ("17", 24)
  ; ("0xFF", 22)
  ; ("48", 19)
  ; ("13", 16)
  ; ("15", 15)
  ; ("12", 15)
  ; ("11", 13)
  ; ("0n", 13)
  ; ("9", 12)
  ; ("31", 12)
  ; ("255", 12)
  ; ("55", 11)
  ; ("64", 10)
  ; ("50", 10)
  ; ("24", 10)
  ; ("1n", 9)
  ; ("0L", 9)
  ; ("256", 8)
  ; ("20", 7)
  ; ("18", 7)
  ; ("22", 6)
  ; ("0x80", 6)
  ; ("0x3F", 6)
  ; ("0l", 6)
  ; ("80", 5)
  ; ("54", 5)
  ; ("53", 5)
  ; ("36", 5)
  ; ("26", 5)
  ; ("0x3FFFFFFF", 5)
  ; ("62", 4)
  ; ("60", 4)
  ; ("59", 4)
  ; ("57", 4)
  ; ("47", 4)
  ; ("44", 4)
  ; ("39", 4)
  ; ("38", 4)
  ; ("37", 4)
  ; ("35", 4)
  ; ("34", 4)
  ; ("33", 4)
  ; ("30", 4)
  ; ("27", 4)
  ; ("25", 4)
  ; ("23", 4)
  ; ("21", 4)
  ; ("19", 4)
  ; ("14", 4)
  ; ("109", 4)
  ; ("103", 4)
  ; ("1024", 4)
  ; ("102", 4)
  ; ("101", 4)
  ; ("0x10FFFF", 4)
  ; ("(-1000000)", 4)
  ; ("99", 3)
  ; ("87", 3)
  ; ("83", 3)
  ; ("61", 3)
  ; ("58", 3)
  ; ("56", 3)
  ; ("52", 3)
  ; ("512", 3)
  ; ("51", 3)
  ; ("49", 3)
  ; ("46", 3)
  ; ("45", 3)
  ; ("43", 3)
  ; ("41", 3)
  ; ("40", 3)
  ; ("29", 3)
  ; ("28", 3)
  ; ("200", 3)
  ; ("1l", 3)
  ; ("1L", 3)
  ; ("115", 3)
  ; ("113", 3)
  ; ("107", 3)
  ; ("105", 3)
  ; ("104", 3)
  ; ("0xFFFF", 3)
  ; ("0x3FF", 3)
  ; ("0x10000", 3)
  ; ("0x1000", 3)
  ; ("0o666", 3)
  ; ("(-8)", 3)
  ; ("(-2)", 3)
  ; ("97", 2)
  ; ("93", 2)
  ; ("78", 2)
  ; ("72", 2)
  ; ("65", 2)
  ; ("500", 2)
  ; ("4096", 2)
  ; ("251", 2)
  ; ("246", 2)
  ; ("245", 2)
  ; ("223", 2)
  ; ("127", 2)
  ; ("114", 2)
  ; ("112", 2)
  ; ("111", 2)
  ; ("110", 2)
  ; ("108", 2)
  ; ("106", 2)
  ; ("100000", 2)
  ; ("10000", 2)
  ; ("0xFFFF_FFFFL", 2)
  ; ("0xDC00", 2)
  ; ("0xD800", 2)
  ; ("0x8000000000000000L", 2)
  ; ("0x7FFF_FFFFL", 2)
  ; ("0x7FFFFFFFFFFFFFFFL", 2)
  ; ("0b111", 2)
  ; ("(-6)", 2)
  ; ("(-3)", 2)
  ; ("(-1n)", 2)
  ; ("(-1l)", 2)
  ; ("(-1L)", 2)
  ; ("(-0x8000_0000L)", 2) *)
  ]
  (* Eliding ints that occur more rarely (not accounted for in counts...oh well it's stats) *)

let const_chars : (expression * Types.type_expr * lprob) list =
  begin fun char_str_and_counts ->
    char_str_and_counts |>@ begin fun (char_str, count) ->
      ( Exp.from_string char_str
      , Predef.type_char
      , lprob_by_counts count const_count
      )
    end
  end @@
  [ ("'\\n'", 28)
  ; ("' '", 26)
  ; ("'\\\\'", 19)
  ; ("'0'", 13)
  ; ("'-'", 13)
  ; ("'%'", 12)
  ; ("'.'", 11)
  ; ("'\\000'", 10)
  (*; ("'+'", 9)
  ; ("'a'", 8)
  ; ("'\"'", 8)
  ; ("'\\t'", 7)
  ; ("'A'", 7)
  ; ("'/'", 7)
  ; ("'_'", 6)
  ; ("','", 6)
  ; ("'*'", 6)
  ; ("'z'", 5)
  ; ("'n'", 5)
  ; ("'='", 5)
  ; ("':'", 5)
  ; ("'~'", 4)
  ; ("'x'", 4)
  ; ("'\\r'", 4)
  ; ("'\\''", 4)
  ; ("'Z'", 4)
  ; ("'#'", 4)
  ; ("'l'", 3)
  ; ("'b'", 3)
  ; ("'^'", 3)
  ; ("'X'", 3)
  ; ("'@'", 3)
  ; ("'9'", 3)
  ; ("')'", 3)
  ; ("'$'", 3)
  ; ("'t'", 2)
  ; ("'r'", 2)
  ; ("']'", 2)
  ; ("'\\b'", 2)
  ; ("'['", 2)
  ; ("'L'", 2)
  ; ("'('", 2)
  ; ("'}'", 1)
  ; ("'|'", 1)
  ; ("'u'", 1)
  ; ("'o'", 1)
  ; ("'i'", 1)
  ; ("'h'", 1)
  ; ("'g'", 1)
  ; ("'f'", 1)
  ; ("'e'", 1)
  ; ("'d'", 1)
  ; ("'\\254'", 1)
  ; ("'\\248'", 1)
  ; ("'\\246'", 1)
  ; ("'\\224'", 1)
  ; ("'\\222'", 1)
  ; ("'\\216'", 1)
  ; ("'\\214'", 1)
  ; ("'\\192'", 1)
  ; ("'R'", 1)
  ; ("'N'", 1)
  ; ("'H'", 1)
  ; ("'G'", 1)
  ; ("'F'", 1)
  ; ("'E'", 1)
  ; ("'?'", 1)
  ; ("'>'", 1)
  ; ("'<'", 1)
  ; ("';'", 1)
  ; ("'&'", 1)
  ; ("'!'", 1) *)
  ]

let const_floats : (expression * Types.type_expr * lprob) list =
  begin fun float_str_and_counts ->
    float_str_and_counts |>@ begin fun (float_str, count) ->
      ( Exp.from_string float_str
      , Predef.type_float
      , lprob_by_counts count const_count
      )
    end
  end @@
  [ ("0.0", 15)
  ; ("1.0", 12)
  ; ("0.", 11)
  ; ("0.5", 5)
  ; ("10.", 3)
  (* ; ("8.", 2)
  ; ("1024.", 2)
  ; ("1.", 2)
  ; ("0.33333", 2)
  ; ("50.", 1)
  ; ("25.", 1)
  ; ("1e3", 1)
  ; ("1073741824.0", 1)
  ; ("0x1.921fb54442d18p+1", 1)
  ; ("0.1", 1) *)
  ]

(* Keyed by how recently introduced. *)
let local_idents : (int * lprob) list =
  begin fun nth_str_and_counts ->
    nth_str_and_counts |>@ begin fun (nth_str, count) ->
      ( nth_str |> String.drop_prefix "NthInEnv " |> int_of_string
      , lprob_by_counts count ident_count
      )
    end
  end @@
  [ ("NthInEnv 0", 24644)
  ; ("NthInEnv 1", 15572)
  ; ("NthInEnv 2", 9133)
  ; ("NthInEnv 3", 5660)
  ; ("NthInEnv 4", 4093)
  ; ("NthInEnv 5", 2573)
  ; ("NthInEnv 6", 2009)
  ; ("NthInEnv 7", 1338)
  ; ("NthInEnv 8", 1288)
  ; ("NthInEnv 11", 1165)
  ; ("NthInEnv 9", 1086)
  ; ("NthInEnv 12", 742)
  ; ("NthInEnv 10", 675)
  ; ("NthInEnv 15", 580)
  ; ("NthInEnv 13", 392)
  ; ("NthInEnv 16", 374)
  ; ("NthInEnv 53", 364)
  ; ("NthInEnv 54", 309)
  ; ("NthInEnv 52", 285)
  ; ("NthInEnv 26", 269)
  ; ("NthInEnv 29", 257)
  ; ("NthInEnv 14", 248)
  ; ("NthInEnv 18", 244)
  ; ("NthInEnv 28", 215)
  ; ("NthInEnv 27", 209)
  ; ("NthInEnv 21", 195)
  ; ("NthInEnv 19", 179)
  ; ("NthInEnv 23", 177)
  ; ("NthInEnv 17", 176)
  ; ("NthInEnv 48", 175)
  ; ("NthInEnv 38", 155)
  ; ("NthInEnv 31", 152)
  ; ("NthInEnv 51", 150)
  ; ("NthInEnv 20", 150)
  ; ("NthInEnv 30", 144)
  ; ("NthInEnv 43", 138)
  ; ("NthInEnv 25", 138)
  ; ("NthInEnv 22", 136)
  ; ("NthInEnv 41", 135)
  ; ("NthInEnv 47", 129)
  ; ("NthInEnv 24", 129)
  ; ("NthInEnv 44", 127)
  ; ("NthInEnv 33", 124)
  ; ("NthInEnv 36", 121)
  ; ("NthInEnv 64", 117)
  ; ("NthInEnv 63", 115)
  ; ("NthInEnv 49", 109)
  ; ("NthInEnv 46", 102)
  ; ("NthInEnv 35", 99)
  ; ("NthInEnv 50", 94)
  ; ("NthInEnv 34", 91)
  ; ("NthInEnv 39", 86)
  ; ("NthInEnv 45", 79)
  ; ("NthInEnv 37", 75)
  ; ("NthInEnv 59", 60)
  ; ("NthInEnv 32", 56)
  ; ("NthInEnv 55", 54)
  ; ("NthInEnv 40", 54)
  ; ("NthInEnv 66", 52)
  ; ("NthInEnv 61", 50)
  ; ("NthInEnv 42", 49)
  ; ("NthInEnv 62", 48)
  ; ("NthInEnv 96", 47)
  ; ("NthInEnv 86", 46)
  ; ("NthInEnv 95", 43)
  ; ("NthInEnv 85", 42)
  ; ("NthInEnv 60", 42)
  ; ("NthInEnv 97", 35)
  ; ("NthInEnv 94", 35)
  ; ("NthInEnv 58", 31)
  ; ("NthInEnv 87", 30)
  ; ("NthInEnv 65", 29)
  ; ("NthInEnv 90", 28)
  ; ("NthInEnv 75", 28)
  ; ("NthInEnv 89", 27)
  ; ("NthInEnv 93", 26)
  ; ("NthInEnv 98", 25)
  ; ("NthInEnv 88", 25)
  ; ("NthInEnv 56", 25)
  ; ("NthInEnv 73", 24)
  ; ("NthInEnv 72", 23)
  ; ("NthInEnv 70", 23)
  ; ("NthInEnv 57", 23)
  ; ("NthInEnv 68", 22)
  ; ("NthInEnv 67", 22)
  ; ("NthInEnv 84", 21)
  ; ("NthInEnv 81", 21)
  ; ("NthInEnv 71", 21)
  ; ("NthInEnv 119", 21)
  ; ("NthInEnv 91", 20)
  ; ("NthInEnv 76", 20)
  ; ("NthInEnv 69", 20)
  ; ("NthInEnv 99", 19)
  ; ("NthInEnv 83", 17)
  ; ("NthInEnv 80", 17)
  ; ("NthInEnv 74", 16)
  ; ("NthInEnv 92", 15)
  ; ("NthInEnv 82", 15)
  ; ("NthInEnv 109", 15)
  ; ("NthInEnv 105", 14)
  ; ("NthInEnv 103", 14)
  ; ("NthInEnv 106", 13)
  ; ("NthInEnv 102", 13)
  ; ("NthInEnv 115", 12)
  ; ("NthInEnv 118", 11)
  ; ("NthInEnv 101", 11)
  ; ("NthInEnv 100", 11)
  ; ("NthInEnv 77", 10)
  ; ("NthInEnv 130", 10)
  ; ("NthInEnv 114", 10)
  ]
  (* Eliding rarer (not accounted for in counts...oh well it's stats) *)

let stdlib_idents : (expression * Types.type_expr * lprob) list =
  begin fun indent_str_and_counts ->
    indent_str_and_counts
    |>@? (fun (ident_str, _) -> not @@ SSet.mem ident_str names_to_skip)
    |>@ begin fun (ident_str, count) ->
      let exp = Exp.from_string @@ "( " ^ ident_str ^ " )" in
      let lid =
        match exp.pexp_desc with
        | Pexp_ident { txt = lid; _ } -> lid
        | _ -> failwith "a;ldskabvksjdbflvskdjs" (* it's searchable *)
      in
      (* print_endline @@ Exp.to_string exp; *)
      ( exp
      , Typing.type_of_longident lid Typing.initial_env
      , lprob_by_counts count ident_count
      )
    end
  end @@
  [ ("!", 1470)
  ; ("Parsing.peek_val", 1282)
  ; ("+", 1180)
  ; ("=", 852)
  ; ("Obj.repr", 848)
  ; (":=", 832)
  ; ("ref", 742)
  ; ("List.map", 591)
  ; (">=", 587)
  ; ("-", 549)
  ; ("invalid_arg", 536)
  ; ("Array.get", 499)
  ; ("raise", 492)
  ; (">", 453)
  ; ("&&", 414)
  ; ("||", 383)
  ; ("^", 377)
  ; ("not", 351)
  ; ("<", 346)
  ; ("List.iter", 322)
  ; ("<>", 264)
  ; ("Format.fprintf", 212)
  ; ("Array.length", 206)
  ; ("@", 185)
  ; ("String.length", 166)
  ; ("List.length", 165)
  ; ("Array.set", 150)
  ; ("List.fold_left", 138)
  ; ("List.rev", 125)
  ; ("Seq.fold_left", 119)
  ; ("Printf.sprintf", 119)
  ; ("*", 116)
  ; ("fst", 110)
  ; ("String.get", 97)
  ; ("incr", 92)
  ; ("Format.asprintf", 91)
  ; ("<=", 82)
  ; ("Array.make", 74)
  ; ("lsl", 73)
  ; ("List.fold_right", 73)
  ; ("==", 67)
  ; ("List.sort_uniq", 64)
  ; ("snd", 63)
  ; ("Printf.fprintf", 62)
  ; ("String.sub", 59)
  ; ("land", 58)
  ; ("ignore", 57)
  ; ("Hashtbl.create", 54)
  ; ("Hashtbl.find", 52)
  ; ("@@", 51)
  ; ("string_of_int", 46)
  ; ("List.exists", 46)
  ; ("output_string", 44)
  ; ("compare", 44)
  ; ("List.mem", 41)
  ; ("Bytes.unsafe_set", 41)
  ; ("Char.code", 40)
  ; ("Hashtbl.add", 39)
  ; ("List.filter", 38)
  ; ("*.", 38)
  ; ("~-", 37)
  ; ("Array.map", 36)
  ; ("Format.eprintf", 35)
  ; ("Array.of_list", 34)
  ; ("|>", 33)
  ; ("Buffer.add_char", 33)
  ; ("/", 32)
  ; ("List.for_all", 30)
  ; ("close_in", 29)
  ; ("String.concat", 29)
  ; ("Char.unsafe_chr", 29)
  ; ("max_int", 27)
  ; ("Obj.magic", 27)
  ; ("Buffer.add_string", 27)
  ; ("+.", 27)
  (* ; ("exit", 26) *)
  ; ("Hashtbl.clear", 26)
  ; ("failwith", 25)
  ; ("Buffer.create", 25)
  ; ("lor", 24)
  ; ("Filename.check_suffix", 23)
  ; ("mod", 22)
  ; ("List.iter2", 22)
  ; ("List.assoc", 22)
  ; ("Bytes.create", 22)
  ; ("Buffer.contents", 22)
  ; ("Array.unsafe_get", 22)
  ; ("Pervasives.compare", 21)
  ; ("Lazy.force", 21)
  ; ("lsr", 20)
  ; ("/.", 20)
  ; ("min", 19)
  ; ("max", 19)
  ; ("output_char", 17)
  ; ("Bytes.length", 17)
  ; ("int_of_char", 16)
  ; ("Sys.max_string_length", 16)
  ; ("List.sort", 16)
  ; ("float_of_int", 15)
  ; ("Nativeint.of_int", 15)
  ; ("Hashtbl.mem", 15)
  ; ("Format.pp_print_text", 15)
  ; ("Format.err_formatter", 15)
  ; ("Filename.quote", 15)
  ; ("Array.sub", 15)
  ; ("stdout", 14)
  ; ("close_out", 14)
  ; ("Sys.getenv", 14)
  ; ("Obj.obj", 14)
  ; ("List.map2", 14)
  ; ("Hashtbl.iter", 14)
  ; ("-.", 14)
  ; ("stderr", 13)
  ; ("prerr_endline", 13)
  ; ("open_in_bin", 13)
  ; ("input_value", 13)
  ; ("Bytes.unsafe_to_string", 13)
  ; ("really_input_string", 12)
  ; ("print_string", 12)
  ; ("flush", 12)
  ; ("asr", 12)
  ; ("Sys.word_size", 12)
  ; ("Sys.argv", 12)
  ; ("String.make", 12)
  ; ("List.rev_map", 12)
  ; ("Hashtbl.hash", 12)
  ; ("Filename.basename", 12)
  ; ("Bytes.get", 12)
  ; ("output_value", 11)
  ; ("List.memq", 11)
  ; ("List.find", 11)
  ; ("lxor", 10)
  ; ("float_of_string", 10)
  ; ("abs", 10)
  ; ("Sys.os_type", 10)
  ; ("Sys.file_exists", 10)
  ; ("String.index", 10)
  ; ("String.compare", 10)
  ; ("Printf.eprintf", 10)
  ; ("Nativeint.shift_left", 10)
  ; ("Char.chr", 10)
  ; ("Bytes.set", 10)
  ; ("Array.iter", 10)
  ; ("int_of_string", 9)
  ; ("String.blit", 9)
  ; ("Obj.tag", 9)
  ; ("Obj.field", 9)
  ; ("List.split", 9)
  ; ("Filename.temp_file", 9)
  ; ("Array.to_list", 9)
  ; ("sqrt", 8)
  ; ("prerr_string", 8)
  ; ("min_int", 8)
  ; ("Printf.printf", 8)
  ; ("Parsing.symbol_start_pos", 8)
  ; ("Obj.set_field", 8)
  ; ("List.tl", 8)
  ; ("List.rev_append", 8)
  ; ("List.nth", 8)
  ; ("Format.pp_print_string", 8)
  ; ("Format.pp_print_char", 8)
  ; ("Filename.remove_extension", 8)
  ; ("Bytes.sub_string", 8)
  ; ("Array.init", 8)
  ; ("decr", 7)
  ; ("abs_float", 7)
  ; ("Printexc.to_string", 7)
  ; ("Parsing.yyparse", 7)
  ; ("Parsing.symbol_end_pos", 7)
  ; ("Parsing.rhs_start_pos", 7)
  ; ("Parsing.rhs_end_pos", 7)
  ; ("Obj.object_tag", 7)
  ; ("Obj.lazy_tag", 7)
  ; ("Obj.forward_tag", 7)
  ; ("List.hd", 7)
  ; ("List.combine", 7)
  ; ("Format.str_formatter", 7)
  ; ("Filename.chop_extension", 7)
  ; ("Bytes.make", 7)
  ; ("!=", 7)
  ; ("float", 6)
  ; ("String.split_on_char", 6)
  ; ("String.capitalize_ascii", 6)
  ; ("Seq.iter", 6)
  ; ("Printf.bprintf", 6)
  ; ("Printexc.raw_backtrace_to_string", 6)
  ; ("Printexc.get_callstack", 6)
  ; ("Nativeint.to_string", 6)
  ; ("Nativeint.logor", 6)
  ; ("List.flatten", 6)
  ; ("Lexing.lexeme_char", 6)
  ; ("Hashtbl.replace", 6)
  ; ("Hashtbl.remove", 6)
  ; ("Hashtbl.fold", 6)
  ; ("Bytes.blit", 6)
  ; ("Array.iteri", 6)
  ; ("Array.fold_left", 6)
  ; ("Array.blit", 6)
  ; ("~-.", 5)
  ; ("succ", 5)
  ; ("pred", 5)
  ; ("open_out_bin", 5)
  ; ("input_line", 5)
  ; ("char_of_int", 5)
  ; ("Queue.create", 5)
  ; ("Obj.size", 5)
  ; ("Obj.new_block", 5)
  ; ("Nativeint.add", 5)
  ; ("List.fold_left2", 5)
  ; ("Int64.of_nativeint", 5)
  ; ("Int64.of_int", 5)
  ; ("Int64.compare", 5)
  ; ("Int64.bits_of_float", 5)
  ; ("Hashtbl.reset", 5)
  ; ("Format.pp_print_list", 5)
  ; ("Format.pp_print_int", 5)
  ; ("Filename.concat", 5)
  ; ("Filename.chop_suffix", 5)
  ; ("seek_in", 4)
  ; ("print_newline", 4)
  ; ("open_in", 4)
  ; ("lnot", 4)
  ; ("int_of_float", 4)
  ; ("String.lowercase_ascii", 4)
  ; ("Queue.add", 4)
  ; ("Obj.double_tag", 4)
  ; ("Obj.custom_tag", 4)
  ; ("Lexing.lexeme", 4)
  ; ("Int64.to_int32", 4)
  ; ("Int64.of_int32", 4)
  ; ("Format.printf", 4)
  ; ("Format.pp_print_cut", 4)
  ; ("Format.flush_str_formatter", 4)
  ; ("Filename.is_implicit", 4)
  ; ("Char.uppercase_ascii", 4)
  ; ("Buffer.clear", 4)
  ; ("Array.copy", 4)
  ; ("string_of_float", 3)
  ; ("print_char", 3)
  ; ("open_out", 3)
  ; ("input", 3)
  ; ("in_channel_length", 3)
  ; ("__LOC__", 3)
  ; ("Weak.set", 3)
  ; ("Uchar.to_int", 3)
  ; ("Sys.ocaml_version", 3)
  ; ("String.unsafe_get", 3)
  ; ("String.uncapitalize_ascii", 3)
  ; ("String.map", 3)
  ; ("String.escaped", 3)
  ; ("Pervasives.close_in", 3)
  ; ("Obj.string_tag", 3)
  ; ("Obj.infix_tag", 3)
  ; ("Obj.double_array_tag", 3)
  ; ("Obj.closure_tag", 3)
  ; ("Nativeint.to_int32", 3)
  ; ("List.partition", 3)
  ; ("List.mem_assoc", 3)
  ; ("List.for_all2", 3)
  ; ("List.concat", 3)
  ; ("List.assq", 3)
  ; ("Int64.shift_left", 3)
  ; ("Int64.one", 3)
  ; ("Int64.neg", 3)
  ; ("Int32.of_int", 3)
  ; ("Filename.open_temp_file", 3)
  ; ("Filename.dirname", 3)
  ; ("Filename.current_dir_name", 3)
  ; ("Digest.file", 3)
  ; ("Buffer.reset", 3)
  ; ("Array.mapi", 3)
  ; ("Array.append", 3)
  ; ("Arg.current", 3)
  ; ("**", 3)
  ]
  (* Eliding rarer (not accounted for in counts...oh well it's stats) *)

let stdlib_pure_idents =
  stdlib_idents
  |> List.filter (fun (_, typ, _) -> not (is_imperative typ))

let pervasives_idents_only =
  stdlib_idents
  |> List.filter (fun (exp, _, _) -> Exp.is_simple_name exp)

let pervasives_pure_idents_only =
  pervasives_idents_only
  |> List.filter (fun (_, typ, _) -> not (is_imperative typ))

let max_single_constant_term_lprob =
  mult_lprobs const_lprob begin
    const_strs @ const_ints @ const_chars @ const_floats
    |>@ Tup3.thd
    |> List.max
  end

(* Use this to reserve probability for other holes! *)
let max_single_term_lprob =
  match local_idents with
  | (_, best_local_ident_given_ident_lprob)::_ -> mult_lprobs ident_lprob best_local_ident_given_ident_lprob
  | _ -> failwith "asjndvoisehbvbhskdjvfkjdfs"
